from turtle import *
import random
import math
tracer(False)
import statistics
bgcolor("skyblue")
turns = [0,90,180,270]
Regs = [0,180]


def Go_Home():
"""This is just to eliminate common code"""
stamp()
penup()
home()
setheading(0)

def code(steps, runs, walk, nums):
"""This is the function that calculates the numbers
and plots the picture, depending on the arguements passed in"""
Pas_Num = []
Mi_Ma_Num = []
Reg_Num = []
for _ in range(runs):
for _ in range(steps):
if walk == "Reg":
left(random.choice(Regs))
penup()
if nums == "yes":
forward(1)
else:
forward(9)
elif walk == "Pa":
left(random.choice(turns))
penup()
if nums == "yes":
forward(1)
else:
forward(9)
elif walk == "MiMa":
left(random.choice(turns))
if heading() == 270:
penup()
if nums == "yes":
forward(2)
else:
forward(18)
else:
penup()
if nums == "yes":
forward(1)
else:
forward(9)


if walk == "Reg":
if nums == "yes":
Reg_Num.append(distance(0,0))
home()
setheading(0)
else:
pendown()
setheading(0)
color("red")
shape("triangle")
Go_Home()
elif walk == "Pa":
if nums == "yes":
Pas_Num.append(distance(0,0))
home()
setheading(0)
else:
pendown()
color("black")
shape("circle")
Go_Home()
elif walk == "MiMa":
if nums == "yes":
Mi_Ma_Num.append(distance(0,0))
home()
setheading(0)
else:
pendown()
color("green")
shape("square")
Go_Home()
if walk == "Pa" and nums == "yes":
print(f"Pa random walk of {steps} steps")
print(f"Mean = {round(statistics.mean(Pas_Num), 1)} CV = {round(statistics.stdev(Pas_Num),1)}")
print(f"Max = {round(max(Pas_Num),1)} Min = {round(min(Pas_Num),1)}\n")
elif walk == "MiMa" and nums == "yes":
print(f"Mi-Ma random walk of {steps} steps")
print(f"Mean = {round(statistics.mean(Mi_Ma_Num),1)} CV = {round(statistics.stdev(Mi_Ma_Num),1)}")
print(f"Max = {round(max(Mi_Ma_Num),1)} Min = {round(min(Mi_Ma_Num),1)}\n")
elif walk == "Reg" and nums == "yes":
print(f"Reg random walk of {steps} steps")
print(f"Mean = {round(statistics.mean(Reg_Num),1)} CV = {round(statistics.stdev(Reg_Num),1)}")
print(f"Max = {round(max(Reg_Num),1)} Min = {round(min(Reg_Num),1)}\n")


def Main():
"""This is the main function that calls the funcion"""
code(100, 50, "Pa", "no")
code(100, 50, "Pa", "yes")
code(1000, 50, "Pa", "yes")
code(100, 50, "MiMa", "no")
code(100, 50, "MiMa", "yes")
code(1000, 50, "MiMa", "yes")
code(100, 50, "Reg", "no")
code(100, 50, "Reg", "yes")
code(1000, 50, "Reg", "yes")


if __name__ == "__main__":
Main()








import statistics as stat
from random import seed, choice
from math import hypot
from turtle import *

#Turtle objects:
pa = Turtle()
mima = Turtle()
reg = Turtle()

pa.color('red')
mima.color('blue')
reg.color('green')


def set_seed(value):
""" This function is used to set the seed for testing.
When testing, this function needs to be called BEFORE main is called
or any of function that uses random numbers.
"""
seed(value)


def main():
numSteps = int(input("enter the number of steps: "))
numTrials = int(input("enter the number of trials: "))

paDist = []
mimaDist = []
regDist = []

for i in range(numTrials):

paWalk = walk(numSteps,'pa')
mimaWalk = walk(numSteps,'mima')
regWalk = walk(numSteps,'reg')

paDist.append(abs(paWalk[0]) + abs(paWalk[1]))
mimaDist.append(abs(mimaWalk[0]) + abs(mimaWalk[1]))
regDist.append(abs(regWalk[0]) + abs(regWalk[1]))

pa.up()
mima.up()
reg.up()

pa.goto(walk(100, 'pa'))
mima.goto(walk(100, 'mima'))
reg.goto(walk(100, 'reg'))

pa.dot()
mima.dot()
reg.dot()

#Once again, there is probably a more efficeint way to handle this output
#CV is the ratio of the average and the standard deviation
print("Pa random walk of ", numSteps)
print("Mean: ", avg(paDist))
print("Max: ", max(paDist))
print("Min: ", min(paDist))
print("CV: ", ( avg(paDist)/stat.stdev(paDist) ) )

print("Mima random walk of ", numSteps)
print("Mean: ", avg(mimaDist))
print("Max: ", max(mimaDist))
print("Min: ", min(mimaDist))
print("CV: ", ( avg(paDist)/stat.stdev(paDist) ) )

print("Reg random walk of ", numSteps)
print("Mean: ", avg(regDist))
print("Max: ", max(regDist))
print("Min: ", min(regDist))
print("CV: ", ( avg(paDist)/stat.stdev(paDist) ) )


def walk(num_steps, walker):
x = 0
y = 0
direction = ''

#Pick a random direction and step that way "number" times
for i in range(num_steps):
direction = choice(['north','south','east','west'])
if direction == 'north':
y += 1
elif direction == 'south':
y -= 1
elif direction == 'east':
x += 1
else: #West is all that's left
x -= 1
#Conditions for each walk type besides pa (default)
if walker == 'mima':
if direction == 'south':
y -= 1
if walker == 'reg':
if direction == 'north' or direction == 'south':
#go east or west the same number instead of n or s; set y back to 0
x += y
y = 0

#return the x,y coordinates
# pass
return (x,y)

def avg(inValues):

average = 0
valuesTotal = 0

#Looks like Python 3 doesn't support index() for dictionaries?
valuesList = list(inValues)

#find the index of the last value + 1 (index starts at 0)
numValues = valuesList.index(valuesList[-1]) + 1

#add the values
for index, i in enumerate(inValues, 1):
valuesTotal += i

average = valuesTotal/numValues

return average

if name == "__main__":
set_seed(20190101)
main()

input("press any key to continue...")











import math
from random import choice
import statistics
import sys
import turtle
def main():
    #this function beings all of the work and calls for the user's input
    turtle_dict =  {}
    split_sys = sys.argv[1].split(',')
    split_sys[0] = int(split_sys[0])
    split_sys[1] = int(split_sys[1])
    trials = int(sys.argv[2])
    model = sys.argv[3]
    simulate(split_sys, trials, model, turtle_dict)
def get_direction(model):
    #this function gives the directions possible for all three models and randomly chooses one
    direction_dict = {'Pa':[(0,1),(1,0),(0,-1),(-1,0)],
              'Mi-ma':[(0,1),(1,0),(0,-1),(0,-1),(-1,0)],
              'Reg':[(1,0),(-1,0)]}
    return choice(direction_dict[model])
def simulate(split_sys, trials, model, turtle_dict):
    #this is the main work done. it takes the coordinates from each model and appends them to a list of coordinates
    #then they print out the ending results
    coordinates = []
    distance = []
    if model == 'Pa':
        for step_choice in split_sys:
            coordinates = []
            distance = []
            for walk in range(trials):
                position = [0,0]
                for step in range(step_choice):
                    x = randomwalk(step_choice, get_direction('Pa'),position)
                coordinates.append(x)
                dist = walk_distance(x)
                distance.append(dist)
                get_direction('Pa')
            print(f'{model} random walk of {step_choice} steps')
            values(distance)
            turtle_dict['Pa'] = coordinates
    elif model == 'Mi-ma':
        for step_choice in split_sys:
            coordinates = []
            distance = []
            for walk in range(trials):
                position = [0,0]
                for step in range(step_choice):
                    x = randomwalk(step_choice, get_direction('Mi-ma'),position)
                coordinates.append(x)
                dist = walk_distance(x)
                distance.append(dist)
                get_direction('Mi-ma')
            print(f'{model} random walk of {step_choice} steps')
            values(distance)
            turtle_dict['Mi-ma'] = coordinates
    elif model == 'Reg':
        for step_choice in split_sys:
            coordinates = []
            distance = []
            for walk in range(trials):
                position = [0,0]
                for step in range(step_choice):
                    x = randomwalk(step_choice, get_direction('Reg'),position)
                coordinates.append(x)
                dist = walk_distance(x)
                distance.append(dist)
                direction_dict['Reg']
            print(f'{model} random walk of {step_choice} steps')
            values(distance)
            turtle_dict['Reg'] = coordinates
    elif model == 'All':
        pa_position = [0,0]
        mima_position = [0,0]
        reg_position = [0,0]
        for step_choice in split_sys:
            coordinates = []
            distance = []
            for walk in range(trials):
                position = [0,0]
                for step in range(step_choice):
                    x = randomwalk(step_choice, get_direction('Pa'),position)
                coordinates.append(x)
                dist = walk_distance(x)
                distance.append(dist)
                get_direction('Pa')
            print(f'Pa random walk of {step_choice} steps')
            values(distance)
            turtle_dict['Pa'] = coordinates
        coordinates = []
        distance = []
        for step_choice in split_sys:
            coordinates = []
            distance = []
            for walk in range(trials):
                position = [0,0]
                for step in range(step_choice):
                    x = randomwalk(step_choice, get_direction('Mi-ma'),position)
                coordinates.append(x)
                dist = walk_distance(x)
                distance.append(dist)
                get_direction('Mi-ma')
            print(f'Mi-ma random walk of {step_choice} steps')
            values(distance)
            turtle_dict['Mi-ma'] = coordinates
        coordinates = []
        distance = []
        for step_choice in split_sys:
            coordinates = []
            distance = []
            for walk in range(trials):
                position = [0,0]
                for step in range(step_choice):
                    x = randomwalk(step_choice, get_direction('Reg'),position)
                coordinates.append(x)
                dist = walk_distance(x)
                distance.append(dist)
                get_direction('Reg')
            print(f'Reg random walk of {step_choice} steps')
            values(distance)
            turtle_dict['Reg'] = coordinates
    else:
        print(f"Incorrect input")
        quit()
def values(distance):
    #this is the mathematic function. it takes all of the coordinates from the list and creates the values
    Mean = statistics.mean(distance)
    CV = statistics.stdev(distance)/Mean
    Max = max(distance)
    Min = min(distance)
    print(f"Mean = {Mean:.1f} CV = {CV:.1f}")
    print(f"Max = {Max:.1f} Min = {Min:.1f}")
def randomwalk(walk_length,c_direction,position):
    #this takes each position taken from any model, and adds it to the previous coordinate which results
    #in the final position for the model
    position[0]+= c_direction[0]
    position[1]+= c_direction[1]
    return position

def walk_distance(position):
    #this is the function that calculates the distance from the final location to the origin point
    x = math.sqrt((position[0]**2) + (position[1]**2))
    return x
def plot():
    #this plots all of the coordinates for each model and places them in a turtle window.
    t = turtle.Turtle()
    t.penup()
    t.speed(0)
    model = "Pa"
    t.color("black")
    t.shape("circle")
    for trial in range(50):
        position = [0,0]
        for step in range(100):
            position = randomwalk(100,get_direction('Pa'),position)
        position[0],position[1] = position[0]*5,position[1]*5
        t.goto(position)
        t.stamp()
    model = "Mi-ma"
    t.color("green")
    t.shape("square")
    for trial in range(50):
        position = [0,0]
        for step in range(100):
            position = randomwalk(100,get_direction('Mi-ma'),position)
        position[0],position[1] = position[0]*5,position[1]*5
        t.goto(position)
        t.stamp()
    model = ("Reg")
    t.color("red")
    t.shape("arrow")
    for trial in range(50):
        position = [0,0]
        for step in range(100):
            position = randomwalk(100,get_direction('Reg'),position)
        position[0],position[1] = position[0]*5,position[1]*5
        t.goto(position)
        t.stamp()
    
main()

def save_to_image(dest='random_walk.png'):
    '''Saves the turtle canvas to dest. Do not modify this function.'''
    with tempfile.NamedTemporaryFile(prefix='random_walk',
                                     suffix='.eps') as tmp:
        turtle.getcanvas().postscript(file=tmp.name)
        subprocess.run(['gs',
                        '-dSAFER',
                        '-o',
                        dest,
                        '-r200',
                        '-dEPSCrop',
                        '-sDEVICE=png16m',
                        tmp.name],
                       stdout=subprocess.DEVNULL)
